{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, PLATFORM_ID, Component, Inject, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport * as i2 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { LinkedList, getBsVer } from 'ngx-bootstrap/utils';\nfunction CarouselComponent_ng_container_1_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\", 7);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_ng_container_1_li_2_Template_li_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const i_r6 = restoredCtx.index;\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r7.selectSlide(i_r6));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const slide_r5 = ctx.$implicit;\n    i0.ɵɵclassProp(\"active\", slide_r5.active === true);\n  }\n}\nfunction CarouselComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"ol\", 5);\n    i0.ɵɵtemplate(2, CarouselComponent_ng_container_1_li_2_Template, 1, 2, \"li\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.indicatorsSlides());\n  }\n}\nfunction CarouselComponent_ng_container_2_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 9);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_ng_container_2_button_2_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r13);\n      const i_r11 = restoredCtx.index;\n      const ctx_r12 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r12.selectSlide(i_r11));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const slide_r10 = ctx.$implicit;\n    const i_r11 = ctx.index;\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"active\", slide_r10.active === true);\n    i0.ɵɵattribute(\"data-bs-target\", \"#carousel\" + ctx_r9.currentId)(\"data-bs-slide-to\", i_r11);\n  }\n}\nfunction CarouselComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 5);\n    i0.ɵɵtemplate(2, CarouselComponent_ng_container_2_button_2_Template, 1, 4, \"button\", 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.indicatorsSlides());\n  }\n}\nfunction CarouselComponent_a_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"a\", 10);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_a_5_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r14.previousSlide());\n    });\n    i0.ɵɵelement(1, \"span\", 11);\n    i0.ɵɵelementStart(2, \"span\", 12);\n    i0.ɵɵtext(3, \"Previous\");\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"disabled\", ctx_r2.checkDisabledClass(\"prev\"));\n    i0.ɵɵattribute(\"data-bs-target\", \"#carousel\" + ctx_r2.currentId);\n  }\n}\nfunction CarouselComponent_a_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r17 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"a\", 13);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_a_6_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r17);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r16.nextSlide());\n    });\n    i0.ɵɵelement(1, \"span\", 14);\n    i0.ɵɵelementStart(2, \"span\", 12);\n    i0.ɵɵtext(3, \"Next\");\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"disabled\", ctx_r3.checkDisabledClass(\"next\"));\n    i0.ɵɵattribute(\"data-bs-target\", \"#carousel\" + ctx_r3.currentId);\n  }\n}\nconst _c0 = function (a0) {\n  return {\n    \"display\": a0\n  };\n};\nconst _c1 = [\"*\"];\nclass CarouselConfig {\n  constructor() {\n    /* Default interval of auto changing of slides */\n    this.interval = 5000;\n    /* Is loop of auto changing of slides can be paused */\n    this.noPause = false;\n    /* Is slides can wrap from the last to the first slide */\n    this.noWrap = false;\n    /* Show carousel-indicators */\n    this.showIndicators = true;\n    /* Slides can be paused on focus */\n    this.pauseOnFocus = false;\n    /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\r\n      of visible elements (itemsPerSlide field) */\n    this.singleSlideOffset = false;\n  }\n}\nCarouselConfig.ɵfac = function CarouselConfig_Factory(t) {\n  return new (t || CarouselConfig)();\n};\nCarouselConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CarouselConfig,\n  factory: CarouselConfig.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\r\n * Returns the index of the last element in the array where predicate is true, and -1\r\n * otherwise.\r\n * @param array The source array to search in\r\n * @param predicate find calls predicate once for each element of the array, in descending\r\n * order, until it finds one where predicate returns true. If such an element is found,\r\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\r\n */\nfunction findLastIndex(array, predicate) {\n  let l = array.length;\n  while (l--) {\n    if (predicate(array[l], l, array)) {\n      return l;\n    }\n  }\n  return -1;\n}\nfunction chunkByNumber(array, size) {\n  const out = [];\n  const n = Math.ceil(array.length / size);\n  let i = 0;\n  while (i < n) {\n    const chunk = array.splice(0, i === n - 1 && size < array.length ? array.length : size);\n    out.push(chunk);\n    i++;\n  }\n  return out;\n}\nfunction isNumber(value) {\n  return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\n/***\r\n * pause (not yet supported) (?string='hover') - event group name which pauses\r\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\r\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\r\n * carousel will not react to keyboard events\r\n * note: swiping not yet supported\r\n */\nvar Direction;\n(function (Direction) {\n  Direction[Direction[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  Direction[Direction[\"NEXT\"] = 1] = \"NEXT\";\n  Direction[Direction[\"PREV\"] = 2] = \"PREV\";\n})(Direction || (Direction = {}));\nlet _currentId = 1;\n/**\r\n * Base element to create carousel\r\n */\nclass CarouselComponent {\n  constructor(config, ngZone, platformId) {\n    this.ngZone = ngZone;\n    this.platformId = platformId;\n    /* If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\n    this.noWrap = false;\n    /*  If `true` — will disable pausing on carousel mouse hover */\n    this.noPause = false;\n    /*  If `true` — carousel-indicators are visible  */\n    this.showIndicators = true;\n    /*  If `true` - autoplay will be stopped on focus */\n    this.pauseOnFocus = false;\n    /* If `true` - carousel indicators indicate slides chunks\r\n       works ONLY if singleSlideOffset = FALSE */\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\r\n       of visible elements (itemsPerSlide field) */\n    this.singleSlideOffset = false;\n    /** Turn on/off animation. Animation doesn't work for multilist carousel */\n    this.isAnimated = false;\n    /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n    this.activeSlideChange = new EventEmitter(false);\n    /** Will be emitted when active slides has been changed in multilist mode */\n    this.slideRangeChange = new EventEmitter();\n    /* Index to start display slides from it */\n    this.startFromIndex = 0;\n    this._interval = 5000;\n    this._slides = new LinkedList();\n    this._currentVisibleSlidesIndex = 0;\n    this.isPlaying = false;\n    this.destroyed = false;\n    this.currentId = 0;\n    this.getActive = slide => slide.active;\n    this.makeSlidesConsistent = slides => {\n      slides.forEach((slide, index) => slide.item.order = index);\n    };\n    Object.assign(this, config);\n    this.currentId = _currentId++;\n  }\n  /** Index of currently displayed slide(started for 0) */\n  set activeSlide(index) {\n    if (this.multilist) {\n      return;\n    }\n    if (isNumber(index)) {\n      this.customActiveSlide = index;\n    }\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n  get activeSlide() {\n    return this._currentActiveSlide || 0;\n  }\n  /**\r\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle\r\n   * automatically.\r\n   */\n  get interval() {\n    return this._interval;\n  }\n  set interval(value) {\n    this._interval = value;\n    this.restartTimer();\n  }\n  get slides() {\n    return this._slides.toArray();\n  }\n  get isFirstSlideVisible() {\n    const indexes = this.getVisibleIndexes();\n    if (!indexes || indexes instanceof Array && !indexes.length) {\n      return false;\n    }\n    return indexes.includes(0);\n  }\n  get isLastSlideVisible() {\n    const indexes = this.getVisibleIndexes();\n    if (!indexes || indexes instanceof Array && !indexes.length) {\n      return false;\n    }\n    return indexes.includes(this._slides.length - 1);\n  }\n  get _bsVer() {\n    return getBsVer();\n  }\n  ngAfterViewInit() {\n    setTimeout(() => {\n      if (this.singleSlideOffset) {\n        this.indicatorsByChunk = false;\n      }\n      if (this.multilist) {\n        this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n        this.selectInitialSlides();\n      }\n      if (this.customActiveSlide && !this.multilist) {\n        this._select(this.customActiveSlide);\n      }\n    }, 0);\n  }\n  ngOnDestroy() {\n    this.destroyed = true;\n  }\n  /**\r\n   * Adds new slide. If this slide is first in collection - set it as active\r\n   * and starts auto changing\r\n   * @param slide\r\n   */\n  addSlide(slide) {\n    this._slides.add(slide);\n    if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n      slide.active = true;\n    }\n    if (!this.multilist && this.isAnimated) {\n      slide.isAnimated = true;\n    }\n    if (!this.multilist && this._slides.length === 1) {\n      this._currentActiveSlide = undefined;\n      if (!this.customActiveSlide) {\n        this.activeSlide = 0;\n      }\n      this.play();\n    }\n    if (this.multilist && this._slides.length > this.itemsPerSlide) {\n      this.play();\n    }\n  }\n  /**\r\n   * Removes specified slide. If this slide is active - will roll to another\r\n   * slide\r\n   * @param slide\r\n   */\n  removeSlide(slide) {\n    const remIndex = this._slides.indexOf(slide);\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n      let nextSlideIndex;\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is\n        // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n        // middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex) ? remIndex : this.noWrap ? remIndex - 1 : 0;\n      }\n      this._slides.remove(remIndex);\n      // prevents exception with changing some value after checking\n      setTimeout(() => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(() => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n    }\n  }\n  nextSlideFromInterval(force = false) {\n    this.move(Direction.NEXT, force);\n  }\n  /**\r\n   * Rolling to next slide\r\n   * @param force: {boolean} if true - will ignore noWrap flag\r\n   */\n  nextSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.NEXT, force);\n  }\n  /**\r\n   * Rolling to previous slide\r\n   * @param force: {boolean} if true - will ignore noWrap flag\r\n   */\n  previousSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.PREV, force);\n  }\n  getFirstVisibleIndex() {\n    return this.slides.findIndex(this.getActive);\n  }\n  getLastVisibleIndex() {\n    return findLastIndex(this.slides, this.getActive);\n  }\n  move(direction, force = false) {\n    const firstVisibleIndex = this.getFirstVisibleIndex();\n    const lastVisibleIndex = this.getLastVisibleIndex();\n    if (this.noWrap) {\n      if (direction === Direction.NEXT && this.isLast(lastVisibleIndex) || direction === Direction.PREV && firstVisibleIndex === 0) {\n        return;\n      }\n    }\n    if (!this.multilist) {\n      this.activeSlide = this.findNextSlideIndex(direction, force) || 0;\n    } else {\n      this.moveMultilist(direction);\n    }\n  }\n  /**\r\n   * Swith slides by enter, space and arrows keys\r\n   * @internal\r\n   */\n  keydownPress(event) {\n    if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n      this.nextSlide();\n      event.preventDefault();\n      return;\n    }\n    if (event.keyCode === 37 || event.key === 'LeftArrow') {\n      this.previousSlide();\n      return;\n    }\n    if (event.keyCode === 39 || event.key === 'RightArrow') {\n      this.nextSlide();\n      return;\n    }\n  }\n  /**\r\n   * Play on mouse leave\r\n   * @internal\r\n   */\n  onMouseLeave() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\r\n   * Play on mouse up\r\n   * @internal\r\n   */\n  onMouseUp() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\r\n   * When slides on focus autoplay is stopped(optional)\r\n   * @internal\r\n   */\n  pauseFocusIn() {\n    if (this.pauseOnFocus) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\r\n   * When slides out of focus autoplay is started\r\n   * @internal\r\n   */\n  pauseFocusOut() {\n    this.play();\n  }\n  /**\r\n   * Rolling to specified slide\r\n   * @param index: {number} index of slide, which must be shown\r\n   */\n  selectSlide(index) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    if (!this.multilist) {\n      this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n    } else {\n      this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n    }\n  }\n  /**\r\n   * Starts a auto changing of slides\r\n   */\n  play() {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n  /**\r\n   * Stops a auto changing of slides\r\n   */\n  pause() {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\r\n   * Finds and returns index of currently displayed slide\r\n   */\n  getCurrentSlideIndex() {\n    return this._slides.findIndex(this.getActive);\n  }\n  /**\r\n   * Defines, whether the specified index is last in collection\r\n   * @param index\r\n   */\n  isLast(index) {\n    return index + 1 >= this._slides.length;\n  }\n  /**\r\n   * Defines, whether the specified index is first in collection\r\n   * @param index\r\n   */\n  isFirst(index) {\n    return index === 0;\n  }\n  indicatorsSlides() {\n    return this.slides.filter((slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0);\n  }\n  selectInitialSlides() {\n    const startIndex = this.startFromIndex <= this._slides.length ? this.startFromIndex : 0;\n    this.hideSlides();\n    if (this.singleSlideOffset) {\n      this._slidesWithIndexes = this.mapSlidesAndIndexes();\n      if (this._slides.length - startIndex < this.itemsPerSlide) {\n        const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n        this._slidesWithIndexes = [...this._slidesWithIndexes, ...slidesToAppend].slice(slidesToAppend.length).slice(0, this.itemsPerSlide);\n      } else {\n        this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n      }\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n    } else {\n      this.selectRangeByNestedIndex(startIndex);\n    }\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n  /**\r\n   * Defines next slide index, depending of direction\r\n   * @param direction: Direction(UNKNOWN|PREV|NEXT)\r\n   * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\r\n   *   return undefined if next slide require wrapping\r\n   */\n  findNextSlideIndex(direction, force) {\n    let nextSlideIndex = 0;\n    if (!force && this.isLast(this.activeSlide) && direction !== Direction.PREV && this.noWrap) {\n      return;\n    }\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled\n        // and need to going forward - select current slide, as a next\n        if (typeof this._currentActiveSlide === 'undefined') {\n          nextSlideIndex = 0;\n          break;\n        }\n        if (!this.isLast(this._currentActiveSlide)) {\n          nextSlideIndex = this._currentActiveSlide + 1;\n          break;\n        }\n        nextSlideIndex = !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled\n        // and need to going backward - select current slide, as a next\n        if (typeof this._currentActiveSlide === 'undefined') {\n          nextSlideIndex = 0;\n          break;\n        }\n        if (this._currentActiveSlide > 0) {\n          nextSlideIndex = this._currentActiveSlide - 1;\n          break;\n        }\n        if (!force && this.noWrap) {\n          nextSlideIndex = this._currentActiveSlide;\n          break;\n        }\n        nextSlideIndex = this._slides.length - 1;\n        break;\n      default:\n        throw new Error('Unknown direction');\n    }\n    return nextSlideIndex;\n  }\n  mapSlidesAndIndexes() {\n    return this.slides.slice().map((slide, index) => {\n      return {\n        index,\n        item: slide\n      };\n    });\n  }\n  selectSlideRange(index) {\n    if (this.isIndexInRange(index)) {\n      return;\n    }\n    this.hideSlides();\n    if (!this.singleSlideOffset) {\n      this.selectRangeByNestedIndex(index);\n    } else {\n      const startIndex = this.isIndexOnTheEdges(index) ? index : index - this.itemsPerSlide + 1;\n      const endIndex = this.isIndexOnTheEdges(index) ? index + this.itemsPerSlide : index + 1;\n      this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n    }\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n  selectRangeByNestedIndex(index) {\n    if (!this._chunkedSlides) {\n      return;\n    }\n    const selectedRange = this._chunkedSlides.map((slidesList, i) => {\n      return {\n        index: i,\n        list: slidesList\n      };\n    }).find(slidesList => {\n      return slidesList.list.find(slide => slide.index === index) !== undefined;\n    });\n    if (!selectedRange) {\n      return;\n    }\n    this._currentVisibleSlidesIndex = selectedRange.index;\n    this._chunkedSlides[selectedRange.index].forEach(slide => {\n      slide.item.active = true;\n    });\n  }\n  isIndexOnTheEdges(index) {\n    return index + 1 - this.itemsPerSlide <= 0 || index + this.itemsPerSlide <= this._slides.length;\n  }\n  isIndexInRange(index) {\n    if (this.singleSlideOffset && this._slidesWithIndexes) {\n      const visibleIndexes = this._slidesWithIndexes.map(slide => slide.index);\n      return visibleIndexes.indexOf(index) >= 0;\n    }\n    return index <= this.getLastVisibleIndex() && index >= this.getFirstVisibleIndex();\n  }\n  hideSlides() {\n    this.slides.forEach(slide => slide.active = false);\n  }\n  isVisibleSlideListLast() {\n    if (!this._chunkedSlides) {\n      return false;\n    }\n    return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n  }\n  isVisibleSlideListFirst() {\n    return this._currentVisibleSlidesIndex === 0;\n  }\n  moveSliderByOneItem(direction) {\n    let firstVisibleIndex;\n    let lastVisibleIndex;\n    let indexToHide;\n    let indexToShow;\n    if (this.noWrap) {\n      firstVisibleIndex = this.getFirstVisibleIndex();\n      lastVisibleIndex = this.getLastVisibleIndex();\n      indexToHide = direction === Direction.NEXT ? firstVisibleIndex : lastVisibleIndex;\n      indexToShow = direction !== Direction.NEXT ? firstVisibleIndex - 1 : !this.isLast(lastVisibleIndex) ? lastVisibleIndex + 1 : 0;\n      const slideToHide = this._slides.get(indexToHide);\n      if (slideToHide) {\n        slideToHide.active = false;\n      }\n      const slideToShow = this._slides.get(indexToShow);\n      if (slideToShow) {\n        slideToShow.active = true;\n      }\n      const slidesToReorder = this.mapSlidesAndIndexes().filter(slide => slide.item.active);\n      this.makeSlidesConsistent(slidesToReorder);\n      if (this.singleSlideOffset) {\n        this._slidesWithIndexes = slidesToReorder;\n      }\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n      return;\n    }\n    if (!this._slidesWithIndexes || !this._slidesWithIndexes[0]) {\n      return;\n    }\n    let index;\n    firstVisibleIndex = this._slidesWithIndexes[0].index;\n    lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n    if (direction === Direction.NEXT) {\n      this._slidesWithIndexes.shift();\n      index = this.isLast(lastVisibleIndex) ? 0 : lastVisibleIndex + 1;\n      const item = this._slides.get(index);\n      if (item) {\n        this._slidesWithIndexes.push({\n          index,\n          item\n        });\n      }\n    } else {\n      this._slidesWithIndexes.pop();\n      index = this.isFirst(firstVisibleIndex) ? this._slides.length - 1 : firstVisibleIndex - 1;\n      const item = this._slides.get(index);\n      if (item) {\n        this._slidesWithIndexes = [{\n          index,\n          item\n        }, ...this._slidesWithIndexes];\n      }\n    }\n    this.hideSlides();\n    this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n    this.makeSlidesConsistent(this._slidesWithIndexes);\n    this.slideRangeChange.emit(this._slidesWithIndexes.map(slide => slide.index));\n  }\n  moveMultilist(direction) {\n    if (this.singleSlideOffset) {\n      this.moveSliderByOneItem(direction);\n    } else {\n      this.hideSlides();\n      if (this.noWrap) {\n        this._currentVisibleSlidesIndex = direction === Direction.NEXT ? this._currentVisibleSlidesIndex + 1 : this._currentVisibleSlidesIndex - 1;\n      } else if (direction === Direction.NEXT) {\n        this._currentVisibleSlidesIndex = this.isVisibleSlideListLast() ? 0 : this._currentVisibleSlidesIndex + 1;\n      } else {\n        if (this.isVisibleSlideListFirst()) {\n          this._currentVisibleSlidesIndex = this._chunkedSlides ? this._chunkedSlides.length - 1 : 0;\n        } else {\n          this._currentVisibleSlidesIndex = this._currentVisibleSlidesIndex - 1;\n        }\n      }\n      if (this._chunkedSlides) {\n        this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(slide => slide.item.active = true);\n      }\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n  }\n  getVisibleIndexes() {\n    if (!this.singleSlideOffset && this._chunkedSlides) {\n      return this._chunkedSlides[this._currentVisibleSlidesIndex].map(slide => slide.index);\n    }\n    if (this._slidesWithIndexes) {\n      return this._slidesWithIndexes.map(slide => slide.index);\n    }\n  }\n  /**\r\n   * Sets a slide, which specified through index, as active\r\n   * @param index\r\n   */\n  _select(index) {\n    if (isNaN(index)) {\n      this.pause();\n      return;\n    }\n    if (!this.multilist && typeof this._currentActiveSlide !== 'undefined') {\n      const currentSlide = this._slides.get(this._currentActiveSlide);\n      if (typeof currentSlide !== 'undefined') {\n        currentSlide.active = false;\n      }\n    }\n    const nextSlide = this._slides.get(index);\n    if (typeof nextSlide !== 'undefined') {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n  /**\r\n   * Starts loop of auto changing of slides\r\n   */\n  restartTimer() {\n    this.resetTimer();\n    const interval = +this.interval;\n    if (!isNaN(interval) && interval > 0 && isPlatformBrowser(this.platformId)) {\n      this.currentInterval = this.ngZone.runOutsideAngular(() => {\n        return window.setInterval(() => {\n          const nInterval = +this.interval;\n          this.ngZone.run(() => {\n            if (this.isPlaying && !isNaN(this.interval) && nInterval > 0 && this.slides.length) {\n              this.nextSlideFromInterval();\n            } else {\n              this.pause();\n            }\n          });\n        }, interval);\n      });\n    }\n  }\n  get multilist() {\n    return this.itemsPerSlide > 1;\n  }\n  /**\r\n   * Stops loop of auto changing of slides\r\n   */\n  resetTimer() {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\n  checkDisabledClass(buttonType) {\n    if (buttonType === 'prev') {\n      return this.activeSlide === 0 && this.noWrap && !this.multilist || this.isFirstSlideVisible && this.noWrap && this.multilist;\n    }\n    return this.isLast(this.activeSlide) && this.noWrap && !this.multilist || this.isLastSlideVisible && this.noWrap && this.multilist;\n  }\n}\nCarouselComponent.ɵfac = function CarouselComponent_Factory(t) {\n  return new (t || CarouselComponent)(i0.ɵɵdirectiveInject(CarouselConfig), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(PLATFORM_ID));\n};\nCarouselComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: CarouselComponent,\n  selectors: [[\"carousel\"]],\n  inputs: {\n    noWrap: \"noWrap\",\n    noPause: \"noPause\",\n    showIndicators: \"showIndicators\",\n    pauseOnFocus: \"pauseOnFocus\",\n    indicatorsByChunk: \"indicatorsByChunk\",\n    itemsPerSlide: \"itemsPerSlide\",\n    singleSlideOffset: \"singleSlideOffset\",\n    isAnimated: \"isAnimated\",\n    activeSlide: \"activeSlide\",\n    startFromIndex: \"startFromIndex\",\n    interval: \"interval\"\n  },\n  outputs: {\n    activeSlideChange: \"activeSlideChange\",\n    slideRangeChange: \"slideRangeChange\"\n  },\n  ngContentSelectors: _c1,\n  decls: 7,\n  vars: 8,\n  consts: [[\"tabindex\", \"0\", 1, \"carousel\", \"slide\", 3, \"id\", \"mouseenter\", \"mouseleave\", \"mouseup\", \"keydown\", \"focusin\", \"focusout\"], [4, \"ngIf\"], [1, \"carousel-inner\", 3, \"ngStyle\"], [\"class\", \"left carousel-control carousel-control-prev\", \"href\", \"javascript:void(0);\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [\"class\", \"right carousel-control carousel-control-next\", \"href\", \"javascript:void(0);\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [1, \"carousel-indicators\"], [3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"], [\"type\", \"button\", \"aria-current\", \"true\", 3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", \"aria-current\", \"true\", 3, \"click\"], [\"href\", \"javascript:void(0);\", \"tabindex\", \"0\", \"role\", \"button\", 1, \"left\", \"carousel-control\", \"carousel-control-prev\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-prev\", \"carousel-control-prev-icon\"], [1, \"sr-only\", \"visually-hidden\"], [\"href\", \"javascript:void(0);\", \"tabindex\", \"0\", \"role\", \"button\", 1, \"right\", \"carousel-control\", \"carousel-control-next\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-next\", \"carousel-control-next-icon\"]],\n  template: function CarouselComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵelementStart(0, \"div\", 0);\n      i0.ɵɵlistener(\"mouseenter\", function CarouselComponent_Template_div_mouseenter_0_listener() {\n        return ctx.pause();\n      })(\"mouseleave\", function CarouselComponent_Template_div_mouseleave_0_listener() {\n        return ctx.onMouseLeave();\n      })(\"mouseup\", function CarouselComponent_Template_div_mouseup_0_listener() {\n        return ctx.onMouseUp();\n      })(\"keydown\", function CarouselComponent_Template_div_keydown_0_listener($event) {\n        return ctx.keydownPress($event);\n      })(\"focusin\", function CarouselComponent_Template_div_focusin_0_listener() {\n        return ctx.pauseFocusIn();\n      })(\"focusout\", function CarouselComponent_Template_div_focusout_0_listener() {\n        return ctx.pauseFocusOut();\n      });\n      i0.ɵɵtemplate(1, CarouselComponent_ng_container_1_Template, 3, 1, \"ng-container\", 1);\n      i0.ɵɵtemplate(2, CarouselComponent_ng_container_2_Template, 3, 1, \"ng-container\", 1);\n      i0.ɵɵelementStart(3, \"div\", 2);\n      i0.ɵɵprojection(4);\n      i0.ɵɵelementEnd();\n      i0.ɵɵtemplate(5, CarouselComponent_a_5_Template, 4, 3, \"a\", 3);\n      i0.ɵɵtemplate(6, CarouselComponent_a_6_Template, 4, 3, \"a\", 4);\n      i0.ɵɵelementEnd();\n    }\n    if (rf & 2) {\n      i0.ɵɵproperty(\"id\", \"carousel\" + ctx.currentId);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", !ctx._bsVer.isBs5 && ctx.showIndicators && ctx.slides.length > 1);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", ctx._bsVer.isBs5 && ctx.showIndicators && ctx.slides.length > 1);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(6, _c0, ctx.multilist ? \"flex\" : \"block\"));\n      i0.ɵɵadvance(2);\n      i0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n    }\n  },\n  dependencies: [i2.NgForOf, i2.NgIf, i2.NgStyle],\n  encapsulation: 2\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselComponent, [{\n    type: Component,\n    args: [{\n      selector: 'carousel',\n      template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"'carousel' + currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"previousSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\"\n    }]\n  }], function () {\n    return [{\n      type: CarouselConfig\n    }, {\n      type: i0.NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, {\n    noWrap: [{\n      type: Input\n    }],\n    noPause: [{\n      type: Input\n    }],\n    showIndicators: [{\n      type: Input\n    }],\n    pauseOnFocus: [{\n      type: Input\n    }],\n    indicatorsByChunk: [{\n      type: Input\n    }],\n    itemsPerSlide: [{\n      type: Input\n    }],\n    singleSlideOffset: [{\n      type: Input\n    }],\n    isAnimated: [{\n      type: Input\n    }],\n    activeSlideChange: [{\n      type: Output\n    }],\n    slideRangeChange: [{\n      type: Output\n    }],\n    activeSlide: [{\n      type: Input\n    }],\n    startFromIndex: [{\n      type: Input\n    }],\n    interval: [{\n      type: Input\n    }]\n  });\n})();\nclass SlideComponent {\n  constructor(carousel) {\n    /** Is current slide active */\n    this.active = false;\n    this.itemWidth = '100%';\n    this.order = 0;\n    this.isAnimated = false;\n    /** Wraps element by appropriate CSS classes */\n    this.addClass = true;\n    this.multilist = false;\n    this.carousel = carousel;\n  }\n  /** Fires changes in container collection after adding a new slide instance */\n  ngOnInit() {\n    this.carousel.addSlide(this);\n    this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n    this.multilist = this.carousel?.itemsPerSlide > 1;\n  }\n  /** Fires changes in container collection after removing of this slide instance */\n  ngOnDestroy() {\n    this.carousel.removeSlide(this);\n  }\n}\nSlideComponent.ɵfac = function SlideComponent_Factory(t) {\n  return new (t || SlideComponent)(i0.ɵɵdirectiveInject(CarouselComponent));\n};\nSlideComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: SlideComponent,\n  selectors: [[\"slide\"]],\n  hostVars: 15,\n  hostBindings: function SlideComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵattribute(\"aria-hidden\", !ctx.active);\n      i0.ɵɵstyleProp(\"width\", ctx.itemWidth)(\"order\", ctx.order);\n      i0.ɵɵclassProp(\"multilist-margin\", ctx.multilist)(\"active\", ctx.active)(\"carousel-animation\", ctx.isAnimated)(\"item\", ctx.addClass)(\"carousel-item\", ctx.addClass);\n    }\n  },\n  inputs: {\n    active: \"active\"\n  },\n  ngContentSelectors: _c1,\n  decls: 2,\n  vars: 2,\n  consts: [[1, \"item\"]],\n  template: function SlideComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵelementStart(0, \"div\", 0);\n      i0.ɵɵprojection(1);\n      i0.ɵɵelementEnd();\n    }\n    if (rf & 2) {\n      i0.ɵɵclassProp(\"active\", ctx.active);\n    }\n  },\n  styles: [\".carousel-animation[_nghost-%COMP%]{transition:opacity .6s ease,visibility .6s ease;float:left}.carousel-animation.active[_nghost-%COMP%]{opacity:1;visibility:visible}.carousel-animation[_nghost-%COMP%]:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}.multilist-margin[_nghost-%COMP%]{margin-right:auto}.carousel-item[_nghost-%COMP%]{perspective:1000px}\"]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SlideComponent, [{\n    type: Component,\n    args: [{\n      selector: 'slide',\n      template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n      host: {\n        '[attr.aria-hidden]': '!active',\n        '[class.multilist-margin]': 'multilist'\n      },\n      styles: [\":host.carousel-animation{transition:opacity .6s ease,visibility .6s ease;float:left}:host.carousel-animation.active{opacity:1;visibility:visible}:host.carousel-animation:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}:host.multilist-margin{margin-right:auto}:host.carousel-item{perspective:1000px}\\n\"]\n    }]\n  }], function () {\n    return [{\n      type: CarouselComponent\n    }];\n  }, {\n    active: [{\n      type: HostBinding,\n      args: ['class.active']\n    }, {\n      type: Input\n    }],\n    itemWidth: [{\n      type: HostBinding,\n      args: ['style.width']\n    }],\n    order: [{\n      type: HostBinding,\n      args: ['style.order']\n    }],\n    isAnimated: [{\n      type: HostBinding,\n      args: ['class.carousel-animation']\n    }],\n    addClass: [{\n      type: HostBinding,\n      args: ['class.item']\n    }, {\n      type: HostBinding,\n      args: ['class.carousel-item']\n    }]\n  });\n})();\nclass CarouselModule {\n  static forRoot() {\n    return {\n      ngModule: CarouselModule,\n      providers: []\n    };\n  }\n}\nCarouselModule.ɵfac = function CarouselModule_Factory(t) {\n  return new (t || CarouselModule)();\n};\nCarouselModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: CarouselModule\n});\nCarouselModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [CommonModule]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [SlideComponent, CarouselComponent],\n      exports: [SlideComponent, CarouselComponent]\n    }]\n  }], null, null);\n})();\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };","map":{"version":3,"names":["i0","Injectable","EventEmitter","PLATFORM_ID","Component","Inject","Input","Output","HostBinding","NgModule","i2","isPlatformBrowser","CommonModule","LinkedList","getBsVer","CarouselComponent_ng_container_1_li_2_Template","rf","ctx","_r8","ɵɵgetCurrentView","ɵɵelementStart","ɵɵlistener","CarouselComponent_ng_container_1_li_2_Template_li_click_0_listener","restoredCtx","ɵɵrestoreView","i_r6","index","ctx_r7","ɵɵnextContext","ɵɵresetView","selectSlide","ɵɵelementEnd","slide_r5","$implicit","ɵɵclassProp","active","CarouselComponent_ng_container_1_Template","ɵɵelementContainerStart","ɵɵtemplate","ɵɵelementContainerEnd","ctx_r0","ɵɵadvance","ɵɵproperty","indicatorsSlides","CarouselComponent_ng_container_2_button_2_Template","_r13","CarouselComponent_ng_container_2_button_2_Template_button_click_0_listener","i_r11","ctx_r12","slide_r10","ctx_r9","ɵɵattribute","currentId","CarouselComponent_ng_container_2_Template","ctx_r1","CarouselComponent_a_5_Template","_r15","CarouselComponent_a_5_Template_a_click_0_listener","ctx_r14","previousSlide","ɵɵelement","ɵɵtext","ctx_r2","checkDisabledClass","CarouselComponent_a_6_Template","_r17","CarouselComponent_a_6_Template_a_click_0_listener","ctx_r16","nextSlide","ctx_r3","_c0","a0","_c1","CarouselConfig","constructor","interval","noPause","noWrap","showIndicators","pauseOnFocus","indicatorsByChunk","itemsPerSlide","singleSlideOffset","ɵfac","CarouselConfig_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","providedIn","ngDevMode","ɵsetClassMetadata","type","args","findLastIndex","array","predicate","l","length","chunkByNumber","size","out","n","Math","ceil","i","chunk","splice","push","isNumber","value","Object","prototype","toString","call","Direction","_currentId","CarouselComponent","config","ngZone","platformId","isAnimated","activeSlideChange","slideRangeChange","startFromIndex","_interval","_slides","_currentVisibleSlidesIndex","isPlaying","destroyed","getActive","slide","makeSlidesConsistent","slides","forEach","item","order","assign","activeSlide","multilist","customActiveSlide","_currentActiveSlide","_select","restartTimer","toArray","isFirstSlideVisible","indexes","getVisibleIndexes","Array","includes","isLastSlideVisible","_bsVer","ngAfterViewInit","setTimeout","_chunkedSlides","mapSlidesAndIndexes","selectInitialSlides","ngOnDestroy","addSlide","add","undefined","play","removeSlide","remIndex","indexOf","nextSlideIndex","isLast","remove","currentSlideIndex","getCurrentSlideIndex","emit","nextSlideFromInterval","force","move","NEXT","PREV","getFirstVisibleIndex","findIndex","getLastVisibleIndex","direction","firstVisibleIndex","lastVisibleIndex","findNextSlideIndex","moveMultilist","keydownPress","event","keyCode","key","preventDefault","onMouseLeave","onMouseUp","pauseFocusIn","resetTimer","pauseFocusOut","selectSlideRange","pause","isFirst","filter","startIndex","hideSlides","_slidesWithIndexes","slidesToAppend","slice","selectRangeByNestedIndex","Error","map","isIndexInRange","isIndexOnTheEdges","endIndex","selectedRange","slidesList","list","find","visibleIndexes","isVisibleSlideListLast","isVisibleSlideListFirst","moveSliderByOneItem","indexToHide","indexToShow","slideToHide","get","slideToShow","slidesToReorder","shift","pop","isNaN","currentSlide","currentInterval","runOutsideAngular","window","setInterval","nInterval","run","clearInterval","buttonType","CarouselComponent_Factory","ɵɵdirectiveInject","NgZone","ɵcmp","ɵɵdefineComponent","selectors","inputs","outputs","ngContentSelectors","decls","vars","consts","template","CarouselComponent_Template","ɵɵprojectionDef","CarouselComponent_Template_div_mouseenter_0_listener","CarouselComponent_Template_div_mouseleave_0_listener","CarouselComponent_Template_div_mouseup_0_listener","CarouselComponent_Template_div_keydown_0_listener","$event","CarouselComponent_Template_div_focusin_0_listener","CarouselComponent_Template_div_focusout_0_listener","ɵɵprojection","isBs5","ɵɵpureFunction1","dependencies","NgForOf","NgIf","NgStyle","encapsulation","selector","decorators","SlideComponent","carousel","itemWidth","addClass","ngOnInit","SlideComponent_Factory","hostVars","hostBindings","SlideComponent_HostBindings","ɵɵstyleProp","SlideComponent_Template","styles","host","CarouselModule","forRoot","ngModule","providers","CarouselModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","declarations","exports"],"sources":["C:/Users/ladyl/Documents/GitHub/Angular_Medicina/node_modules/ngx-bootstrap/carousel/fesm2020/ngx-bootstrap-carousel.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\r\nimport { Injectable, EventEmitter, PLATFORM_ID, Component, Inject, Input, Output, HostBinding, NgModule } from '@angular/core';\r\nimport * as i2 from '@angular/common';\r\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\r\nimport { LinkedList, getBsVer } from 'ngx-bootstrap/utils';\r\n\r\nclass CarouselConfig {\r\n    constructor() {\r\n        /* Default interval of auto changing of slides */\r\n        this.interval = 5000;\r\n        /* Is loop of auto changing of slides can be paused */\r\n        this.noPause = false;\r\n        /* Is slides can wrap from the last to the first slide */\r\n        this.noWrap = false;\r\n        /* Show carousel-indicators */\r\n        this.showIndicators = true;\r\n        /* Slides can be paused on focus */\r\n        this.pauseOnFocus = false;\r\n        /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\r\n        this.indicatorsByChunk = false;\r\n        /* If value more then 1 — carousel works in multilist mode */\r\n        this.itemsPerSlide = 1;\r\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\r\n          of visible elements (itemsPerSlide field) */\r\n        this.singleSlideOffset = false;\r\n    }\r\n}\r\nCarouselConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nCarouselConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselConfig, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselConfig, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }] });\r\n\r\n/**\r\n * Returns the index of the last element in the array where predicate is true, and -1\r\n * otherwise.\r\n * @param array The source array to search in\r\n * @param predicate find calls predicate once for each element of the array, in descending\r\n * order, until it finds one where predicate returns true. If such an element is found,\r\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\r\n */\r\nfunction findLastIndex(array, predicate) {\r\n    let l = array.length;\r\n    while (l--) {\r\n        if (predicate(array[l], l, array)) {\r\n            return l;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nfunction chunkByNumber(array, size) {\r\n    const out = [];\r\n    const n = Math.ceil((array.length) / size);\r\n    let i = 0;\r\n    while (i < n) {\r\n        const chunk = array.splice(0, (i === n - 1) && size < array.length ? array.length : size);\r\n        out.push(chunk);\r\n        i++;\r\n    }\r\n    return out;\r\n}\r\nfunction isNumber(value) {\r\n    return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\r\n}\r\n\r\n/***\r\n * pause (not yet supported) (?string='hover') - event group name which pauses\r\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\r\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\r\n * carousel will not react to keyboard events\r\n * note: swiping not yet supported\r\n */\r\nvar Direction;\r\n(function (Direction) {\r\n    Direction[Direction[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\r\n    Direction[Direction[\"NEXT\"] = 1] = \"NEXT\";\r\n    Direction[Direction[\"PREV\"] = 2] = \"PREV\";\r\n})(Direction || (Direction = {}));\r\nlet _currentId = 1;\r\n/**\r\n * Base element to create carousel\r\n */\r\nclass CarouselComponent {\r\n    constructor(config, ngZone, platformId) {\r\n        this.ngZone = ngZone;\r\n        this.platformId = platformId;\r\n        /* If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\r\n        this.noWrap = false;\r\n        /*  If `true` — will disable pausing on carousel mouse hover */\r\n        this.noPause = false;\r\n        /*  If `true` — carousel-indicators are visible  */\r\n        this.showIndicators = true;\r\n        /*  If `true` - autoplay will be stopped on focus */\r\n        this.pauseOnFocus = false;\r\n        /* If `true` - carousel indicators indicate slides chunks\r\n           works ONLY if singleSlideOffset = FALSE */\r\n        this.indicatorsByChunk = false;\r\n        /* If value more then 1 — carousel works in multilist mode */\r\n        this.itemsPerSlide = 1;\r\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\r\n           of visible elements (itemsPerSlide field) */\r\n        this.singleSlideOffset = false;\r\n        /** Turn on/off animation. Animation doesn't work for multilist carousel */\r\n        this.isAnimated = false;\r\n        /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\r\n        this.activeSlideChange = new EventEmitter(false);\r\n        /** Will be emitted when active slides has been changed in multilist mode */\r\n        this.slideRangeChange = new EventEmitter();\r\n        /* Index to start display slides from it */\r\n        this.startFromIndex = 0;\r\n        this._interval = 5000;\r\n        this._slides = new LinkedList();\r\n        this._currentVisibleSlidesIndex = 0;\r\n        this.isPlaying = false;\r\n        this.destroyed = false;\r\n        this.currentId = 0;\r\n        this.getActive = (slide) => slide.active;\r\n        this.makeSlidesConsistent = (slides) => {\r\n            slides.forEach((slide, index) => slide.item.order = index);\r\n        };\r\n        Object.assign(this, config);\r\n        this.currentId = _currentId++;\r\n    }\r\n    /** Index of currently displayed slide(started for 0) */\r\n    set activeSlide(index) {\r\n        if (this.multilist) {\r\n            return;\r\n        }\r\n        if (isNumber(index)) {\r\n            this.customActiveSlide = index;\r\n        }\r\n        if (this._slides.length && index !== this._currentActiveSlide) {\r\n            this._select(index);\r\n        }\r\n    }\r\n    get activeSlide() {\r\n        return this._currentActiveSlide || 0;\r\n    }\r\n    /**\r\n     * Delay of item cycling in milliseconds. If false, carousel won't cycle\r\n     * automatically.\r\n     */\r\n    get interval() {\r\n        return this._interval;\r\n    }\r\n    set interval(value) {\r\n        this._interval = value;\r\n        this.restartTimer();\r\n    }\r\n    get slides() {\r\n        return this._slides.toArray();\r\n    }\r\n    get isFirstSlideVisible() {\r\n        const indexes = this.getVisibleIndexes();\r\n        if (!indexes || (indexes instanceof Array && !indexes.length)) {\r\n            return false;\r\n        }\r\n        return indexes.includes(0);\r\n    }\r\n    get isLastSlideVisible() {\r\n        const indexes = this.getVisibleIndexes();\r\n        if (!indexes || (indexes instanceof Array && !indexes.length)) {\r\n            return false;\r\n        }\r\n        return indexes.includes(this._slides.length - 1);\r\n    }\r\n    get _bsVer() {\r\n        return getBsVer();\r\n    }\r\n    ngAfterViewInit() {\r\n        setTimeout(() => {\r\n            if (this.singleSlideOffset) {\r\n                this.indicatorsByChunk = false;\r\n            }\r\n            if (this.multilist) {\r\n                this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\r\n                this.selectInitialSlides();\r\n            }\r\n            if (this.customActiveSlide && !this.multilist) {\r\n                this._select(this.customActiveSlide);\r\n            }\r\n        }, 0);\r\n    }\r\n    ngOnDestroy() {\r\n        this.destroyed = true;\r\n    }\r\n    /**\r\n     * Adds new slide. If this slide is first in collection - set it as active\r\n     * and starts auto changing\r\n     * @param slide\r\n     */\r\n    addSlide(slide) {\r\n        this._slides.add(slide);\r\n        if (this.multilist && this._slides.length <= this.itemsPerSlide) {\r\n            slide.active = true;\r\n        }\r\n        if (!this.multilist && this.isAnimated) {\r\n            slide.isAnimated = true;\r\n        }\r\n        if (!this.multilist && this._slides.length === 1) {\r\n            this._currentActiveSlide = undefined;\r\n            if (!this.customActiveSlide) {\r\n                this.activeSlide = 0;\r\n            }\r\n            this.play();\r\n        }\r\n        if (this.multilist && this._slides.length > this.itemsPerSlide) {\r\n            this.play();\r\n        }\r\n    }\r\n    /**\r\n     * Removes specified slide. If this slide is active - will roll to another\r\n     * slide\r\n     * @param slide\r\n     */\r\n    removeSlide(slide) {\r\n        const remIndex = this._slides.indexOf(slide);\r\n        if (this._currentActiveSlide === remIndex) {\r\n            // removing of active slide\r\n            let nextSlideIndex;\r\n            if (this._slides.length > 1) {\r\n                // if this slide last - will roll to first slide, if noWrap flag is\r\n                // FALSE or to previous, if noWrap is TRUE in case, if this slide in\r\n                // middle of collection, index of next slide is same to removed\r\n                nextSlideIndex = !this.isLast(remIndex)\r\n                    ? remIndex\r\n                    : this.noWrap ? remIndex - 1 : 0;\r\n            }\r\n            this._slides.remove(remIndex);\r\n            // prevents exception with changing some value after checking\r\n            setTimeout(() => {\r\n                this._select(nextSlideIndex);\r\n            }, 0);\r\n        }\r\n        else {\r\n            this._slides.remove(remIndex);\r\n            const currentSlideIndex = this.getCurrentSlideIndex();\r\n            setTimeout(() => {\r\n                // after removing, need to actualize index of current active slide\r\n                this._currentActiveSlide = currentSlideIndex;\r\n                this.activeSlideChange.emit(this._currentActiveSlide);\r\n            }, 0);\r\n        }\r\n    }\r\n    nextSlideFromInterval(force = false) {\r\n        this.move(Direction.NEXT, force);\r\n    }\r\n    /**\r\n     * Rolling to next slide\r\n     * @param force: {boolean} if true - will ignore noWrap flag\r\n     */\r\n    nextSlide(force = false) {\r\n        if (this.isPlaying) {\r\n            this.restartTimer();\r\n        }\r\n        this.move(Direction.NEXT, force);\r\n    }\r\n    /**\r\n     * Rolling to previous slide\r\n     * @param force: {boolean} if true - will ignore noWrap flag\r\n     */\r\n    previousSlide(force = false) {\r\n        if (this.isPlaying) {\r\n            this.restartTimer();\r\n        }\r\n        this.move(Direction.PREV, force);\r\n    }\r\n    getFirstVisibleIndex() {\r\n        return this.slides.findIndex(this.getActive);\r\n    }\r\n    getLastVisibleIndex() {\r\n        return findLastIndex(this.slides, this.getActive);\r\n    }\r\n    move(direction, force = false) {\r\n        const firstVisibleIndex = this.getFirstVisibleIndex();\r\n        const lastVisibleIndex = this.getLastVisibleIndex();\r\n        if (this.noWrap) {\r\n            if (direction === Direction.NEXT &&\r\n                this.isLast(lastVisibleIndex) ||\r\n                direction === Direction.PREV &&\r\n                    firstVisibleIndex === 0) {\r\n                return;\r\n            }\r\n        }\r\n        if (!this.multilist) {\r\n            this.activeSlide = this.findNextSlideIndex(direction, force) || 0;\r\n        }\r\n        else {\r\n            this.moveMultilist(direction);\r\n        }\r\n    }\r\n    /**\r\n     * Swith slides by enter, space and arrows keys\r\n     * @internal\r\n     */\r\n    keydownPress(event) {\r\n        if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\r\n            this.nextSlide();\r\n            event.preventDefault();\r\n            return;\r\n        }\r\n        if (event.keyCode === 37 || event.key === 'LeftArrow') {\r\n            this.previousSlide();\r\n            return;\r\n        }\r\n        if (event.keyCode === 39 || event.key === 'RightArrow') {\r\n            this.nextSlide();\r\n            return;\r\n        }\r\n    }\r\n    /**\r\n     * Play on mouse leave\r\n     * @internal\r\n     */\r\n    onMouseLeave() {\r\n        if (!this.pauseOnFocus) {\r\n            this.play();\r\n        }\r\n    }\r\n    /**\r\n     * Play on mouse up\r\n     * @internal\r\n     */\r\n    onMouseUp() {\r\n        if (!this.pauseOnFocus) {\r\n            this.play();\r\n        }\r\n    }\r\n    /**\r\n     * When slides on focus autoplay is stopped(optional)\r\n     * @internal\r\n     */\r\n    pauseFocusIn() {\r\n        if (this.pauseOnFocus) {\r\n            this.isPlaying = false;\r\n            this.resetTimer();\r\n        }\r\n    }\r\n    /**\r\n     * When slides out of focus autoplay is started\r\n     * @internal\r\n     */\r\n    pauseFocusOut() {\r\n        this.play();\r\n    }\r\n    /**\r\n     * Rolling to specified slide\r\n     * @param index: {number} index of slide, which must be shown\r\n     */\r\n    selectSlide(index) {\r\n        if (this.isPlaying) {\r\n            this.restartTimer();\r\n        }\r\n        if (!this.multilist) {\r\n            this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\r\n        }\r\n        else {\r\n            this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\r\n        }\r\n    }\r\n    /**\r\n     * Starts a auto changing of slides\r\n     */\r\n    play() {\r\n        if (!this.isPlaying) {\r\n            this.isPlaying = true;\r\n            this.restartTimer();\r\n        }\r\n    }\r\n    /**\r\n     * Stops a auto changing of slides\r\n     */\r\n    pause() {\r\n        if (!this.noPause) {\r\n            this.isPlaying = false;\r\n            this.resetTimer();\r\n        }\r\n    }\r\n    /**\r\n     * Finds and returns index of currently displayed slide\r\n     */\r\n    getCurrentSlideIndex() {\r\n        return this._slides.findIndex(this.getActive);\r\n    }\r\n    /**\r\n     * Defines, whether the specified index is last in collection\r\n     * @param index\r\n     */\r\n    isLast(index) {\r\n        return index + 1 >= this._slides.length;\r\n    }\r\n    /**\r\n     * Defines, whether the specified index is first in collection\r\n     * @param index\r\n     */\r\n    isFirst(index) {\r\n        return index === 0;\r\n    }\r\n    indicatorsSlides() {\r\n        return this.slides.filter((slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0);\r\n    }\r\n    selectInitialSlides() {\r\n        const startIndex = this.startFromIndex <= this._slides.length\r\n            ? this.startFromIndex\r\n            : 0;\r\n        this.hideSlides();\r\n        if (this.singleSlideOffset) {\r\n            this._slidesWithIndexes = this.mapSlidesAndIndexes();\r\n            if (this._slides.length - startIndex < this.itemsPerSlide) {\r\n                const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\r\n                this._slidesWithIndexes = [\r\n                    ...this._slidesWithIndexes,\r\n                    ...slidesToAppend\r\n                ]\r\n                    .slice(slidesToAppend.length)\r\n                    .slice(0, this.itemsPerSlide);\r\n            }\r\n            else {\r\n                this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\r\n            }\r\n            this._slidesWithIndexes.forEach((slide) => slide.item.active = true);\r\n            this.makeSlidesConsistent(this._slidesWithIndexes);\r\n        }\r\n        else {\r\n            this.selectRangeByNestedIndex(startIndex);\r\n        }\r\n        this.slideRangeChange.emit(this.getVisibleIndexes());\r\n    }\r\n    /**\r\n     * Defines next slide index, depending of direction\r\n     * @param direction: Direction(UNKNOWN|PREV|NEXT)\r\n     * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\r\n     *   return undefined if next slide require wrapping\r\n     */\r\n    findNextSlideIndex(direction, force) {\r\n        let nextSlideIndex = 0;\r\n        if (!force &&\r\n            (this.isLast(this.activeSlide) &&\r\n                direction !== Direction.PREV &&\r\n                this.noWrap)) {\r\n            return;\r\n        }\r\n        switch (direction) {\r\n            case Direction.NEXT:\r\n                // if this is last slide, not force, looping is disabled\r\n                // and need to going forward - select current slide, as a next\r\n                if (typeof this._currentActiveSlide === 'undefined') {\r\n                    nextSlideIndex = 0;\r\n                    break;\r\n                }\r\n                if (!this.isLast(this._currentActiveSlide)) {\r\n                    nextSlideIndex = this._currentActiveSlide + 1;\r\n                    break;\r\n                }\r\n                nextSlideIndex = !force && this.noWrap ? this._currentActiveSlide : 0;\r\n                break;\r\n            case Direction.PREV:\r\n                // if this is first slide, not force, looping is disabled\r\n                // and need to going backward - select current slide, as a next\r\n                if (typeof this._currentActiveSlide === 'undefined') {\r\n                    nextSlideIndex = 0;\r\n                    break;\r\n                }\r\n                if (this._currentActiveSlide > 0) {\r\n                    nextSlideIndex = this._currentActiveSlide - 1;\r\n                    break;\r\n                }\r\n                if (!force && this.noWrap) {\r\n                    nextSlideIndex = this._currentActiveSlide;\r\n                    break;\r\n                }\r\n                nextSlideIndex = this._slides.length - 1;\r\n                break;\r\n            default:\r\n                throw new Error('Unknown direction');\r\n        }\r\n        return nextSlideIndex;\r\n    }\r\n    mapSlidesAndIndexes() {\r\n        return this.slides\r\n            .slice()\r\n            .map((slide, index) => {\r\n            return {\r\n                index,\r\n                item: slide\r\n            };\r\n        });\r\n    }\r\n    selectSlideRange(index) {\r\n        if (this.isIndexInRange(index)) {\r\n            return;\r\n        }\r\n        this.hideSlides();\r\n        if (!this.singleSlideOffset) {\r\n            this.selectRangeByNestedIndex(index);\r\n        }\r\n        else {\r\n            const startIndex = this.isIndexOnTheEdges(index)\r\n                ? index\r\n                : index - this.itemsPerSlide + 1;\r\n            const endIndex = this.isIndexOnTheEdges(index)\r\n                ? index + this.itemsPerSlide\r\n                : index + 1;\r\n            this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\r\n            this.makeSlidesConsistent(this._slidesWithIndexes);\r\n            this._slidesWithIndexes.forEach((slide) => slide.item.active = true);\r\n        }\r\n        this.slideRangeChange.emit(this.getVisibleIndexes());\r\n    }\r\n    selectRangeByNestedIndex(index) {\r\n        if (!this._chunkedSlides) {\r\n            return;\r\n        }\r\n        const selectedRange = this._chunkedSlides\r\n            .map((slidesList, i) => {\r\n            return {\r\n                index: i,\r\n                list: slidesList\r\n            };\r\n        })\r\n            .find((slidesList) => {\r\n            return slidesList.list.find(slide => slide.index === index) !== undefined;\r\n        });\r\n        if (!selectedRange) {\r\n            return;\r\n        }\r\n        this._currentVisibleSlidesIndex = selectedRange.index;\r\n        this._chunkedSlides[selectedRange.index].forEach((slide) => {\r\n            slide.item.active = true;\r\n        });\r\n    }\r\n    isIndexOnTheEdges(index) {\r\n        return (index + 1 - this.itemsPerSlide <= 0 ||\r\n            index + this.itemsPerSlide <= this._slides.length);\r\n    }\r\n    isIndexInRange(index) {\r\n        if (this.singleSlideOffset && this._slidesWithIndexes) {\r\n            const visibleIndexes = this._slidesWithIndexes.map((slide) => slide.index);\r\n            return visibleIndexes.indexOf(index) >= 0;\r\n        }\r\n        return (index <= this.getLastVisibleIndex() &&\r\n            index >= this.getFirstVisibleIndex());\r\n    }\r\n    hideSlides() {\r\n        this.slides.forEach((slide) => slide.active = false);\r\n    }\r\n    isVisibleSlideListLast() {\r\n        if (!this._chunkedSlides) {\r\n            return false;\r\n        }\r\n        return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\r\n    }\r\n    isVisibleSlideListFirst() {\r\n        return this._currentVisibleSlidesIndex === 0;\r\n    }\r\n    moveSliderByOneItem(direction) {\r\n        let firstVisibleIndex;\r\n        let lastVisibleIndex;\r\n        let indexToHide;\r\n        let indexToShow;\r\n        if (this.noWrap) {\r\n            firstVisibleIndex = this.getFirstVisibleIndex();\r\n            lastVisibleIndex = this.getLastVisibleIndex();\r\n            indexToHide = direction === Direction.NEXT\r\n                ? firstVisibleIndex\r\n                : lastVisibleIndex;\r\n            indexToShow = direction !== Direction.NEXT\r\n                ? firstVisibleIndex - 1\r\n                : !this.isLast(lastVisibleIndex)\r\n                    ? lastVisibleIndex + 1 : 0;\r\n            const slideToHide = this._slides.get(indexToHide);\r\n            if (slideToHide) {\r\n                slideToHide.active = false;\r\n            }\r\n            const slideToShow = this._slides.get(indexToShow);\r\n            if (slideToShow) {\r\n                slideToShow.active = true;\r\n            }\r\n            const slidesToReorder = this.mapSlidesAndIndexes().filter((slide) => slide.item.active);\r\n            this.makeSlidesConsistent(slidesToReorder);\r\n            if (this.singleSlideOffset) {\r\n                this._slidesWithIndexes = slidesToReorder;\r\n            }\r\n            this.slideRangeChange.emit(this.getVisibleIndexes());\r\n            return;\r\n        }\r\n        if (!this._slidesWithIndexes || !this._slidesWithIndexes[0]) {\r\n            return;\r\n        }\r\n        let index;\r\n        firstVisibleIndex = this._slidesWithIndexes[0].index;\r\n        lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\r\n        if (direction === Direction.NEXT) {\r\n            this._slidesWithIndexes.shift();\r\n            index = this.isLast(lastVisibleIndex)\r\n                ? 0\r\n                : lastVisibleIndex + 1;\r\n            const item = this._slides.get(index);\r\n            if (item) {\r\n                this._slidesWithIndexes.push({ index, item });\r\n            }\r\n        }\r\n        else {\r\n            this._slidesWithIndexes.pop();\r\n            index = this.isFirst(firstVisibleIndex)\r\n                ? this._slides.length - 1\r\n                : firstVisibleIndex - 1;\r\n            const item = this._slides.get(index);\r\n            if (item) {\r\n                this._slidesWithIndexes = [{ index, item }, ...this._slidesWithIndexes];\r\n            }\r\n        }\r\n        this.hideSlides();\r\n        this._slidesWithIndexes.forEach(slide => slide.item.active = true);\r\n        this.makeSlidesConsistent(this._slidesWithIndexes);\r\n        this.slideRangeChange.emit(this._slidesWithIndexes.map((slide) => slide.index));\r\n    }\r\n    moveMultilist(direction) {\r\n        if (this.singleSlideOffset) {\r\n            this.moveSliderByOneItem(direction);\r\n        }\r\n        else {\r\n            this.hideSlides();\r\n            if (this.noWrap) {\r\n                this._currentVisibleSlidesIndex = direction === Direction.NEXT\r\n                    ? this._currentVisibleSlidesIndex + 1\r\n                    : this._currentVisibleSlidesIndex - 1;\r\n            }\r\n            else if (direction === Direction.NEXT) {\r\n                this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()\r\n                    ? 0\r\n                    : this._currentVisibleSlidesIndex + 1;\r\n            }\r\n            else {\r\n                if (this.isVisibleSlideListFirst()) {\r\n                    this._currentVisibleSlidesIndex = this._chunkedSlides\r\n                        ? this._chunkedSlides.length - 1\r\n                        : 0;\r\n                }\r\n                else {\r\n                    this._currentVisibleSlidesIndex = this._currentVisibleSlidesIndex - 1;\r\n                }\r\n            }\r\n            if (this._chunkedSlides) {\r\n                this._chunkedSlides[this._currentVisibleSlidesIndex].forEach((slide) => slide.item.active = true);\r\n            }\r\n            this.slideRangeChange.emit(this.getVisibleIndexes());\r\n        }\r\n    }\r\n    getVisibleIndexes() {\r\n        if (!this.singleSlideOffset && this._chunkedSlides) {\r\n            return this._chunkedSlides[this._currentVisibleSlidesIndex]\r\n                .map((slide) => slide.index);\r\n        }\r\n        if (this._slidesWithIndexes) {\r\n            return this._slidesWithIndexes.map((slide) => slide.index);\r\n        }\r\n    }\r\n    /**\r\n     * Sets a slide, which specified through index, as active\r\n     * @param index\r\n     */\r\n    _select(index) {\r\n        if (isNaN(index)) {\r\n            this.pause();\r\n            return;\r\n        }\r\n        if (!this.multilist && typeof this._currentActiveSlide !== 'undefined') {\r\n            const currentSlide = this._slides.get(this._currentActiveSlide);\r\n            if (typeof currentSlide !== 'undefined') {\r\n                currentSlide.active = false;\r\n            }\r\n        }\r\n        const nextSlide = this._slides.get(index);\r\n        if (typeof nextSlide !== 'undefined') {\r\n            this._currentActiveSlide = index;\r\n            nextSlide.active = true;\r\n            this.activeSlide = index;\r\n            this.activeSlideChange.emit(index);\r\n        }\r\n    }\r\n    /**\r\n     * Starts loop of auto changing of slides\r\n     */\r\n    restartTimer() {\r\n        this.resetTimer();\r\n        const interval = +this.interval;\r\n        if (!isNaN(interval) && interval > 0 && isPlatformBrowser(this.platformId)) {\r\n            this.currentInterval = this.ngZone.runOutsideAngular(() => {\r\n                return window.setInterval(() => {\r\n                    const nInterval = +this.interval;\r\n                    this.ngZone.run(() => {\r\n                        if (this.isPlaying &&\r\n                            !isNaN(this.interval) &&\r\n                            nInterval > 0 &&\r\n                            this.slides.length) {\r\n                            this.nextSlideFromInterval();\r\n                        }\r\n                        else {\r\n                            this.pause();\r\n                        }\r\n                    });\r\n                }, interval);\r\n            });\r\n        }\r\n    }\r\n    get multilist() {\r\n        return this.itemsPerSlide > 1;\r\n    }\r\n    /**\r\n     * Stops loop of auto changing of slides\r\n     */\r\n    resetTimer() {\r\n        if (this.currentInterval) {\r\n            clearInterval(this.currentInterval);\r\n            this.currentInterval = void 0;\r\n        }\r\n    }\r\n    checkDisabledClass(buttonType) {\r\n        if (buttonType === 'prev') {\r\n            return (this.activeSlide === 0 && this.noWrap && !this.multilist) || (this.isFirstSlideVisible && this.noWrap && this.multilist);\r\n        }\r\n        return (this.isLast(this.activeSlide) && this.noWrap && !this.multilist) || (this.isLastSlideVisible && this.noWrap && this.multilist);\r\n    }\r\n}\r\nCarouselComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselComponent, deps: [{ token: CarouselConfig }, { token: i0.NgZone }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Component });\r\nCarouselComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"15.0.3\", type: CarouselComponent, selector: \"carousel\", inputs: { noWrap: \"noWrap\", noPause: \"noPause\", showIndicators: \"showIndicators\", pauseOnFocus: \"pauseOnFocus\", indicatorsByChunk: \"indicatorsByChunk\", itemsPerSlide: \"itemsPerSlide\", singleSlideOffset: \"singleSlideOffset\", isAnimated: \"isAnimated\", activeSlide: \"activeSlide\", startFromIndex: \"startFromIndex\", interval: \"interval\" }, outputs: { activeSlideChange: \"activeSlideChange\", slideRangeChange: \"slideRangeChange\" }, ngImport: i0, template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"'carousel' + currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"previousSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\", dependencies: [{ kind: \"directive\", type: i2.NgForOf, selector: \"[ngFor][ngForOf]\", inputs: [\"ngForOf\", \"ngForTrackBy\", \"ngForTemplate\"] }, { kind: \"directive\", type: i2.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { kind: \"directive\", type: i2.NgStyle, selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselComponent, decorators: [{\r\n            type: Component,\r\n            args: [{ selector: 'carousel', template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"'carousel' + currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"previousSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\" }]\r\n        }], ctorParameters: function () { return [{ type: CarouselConfig }, { type: i0.NgZone }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [PLATFORM_ID]\r\n                }] }]; }, propDecorators: { noWrap: [{\r\n                type: Input\r\n            }], noPause: [{\r\n                type: Input\r\n            }], showIndicators: [{\r\n                type: Input\r\n            }], pauseOnFocus: [{\r\n                type: Input\r\n            }], indicatorsByChunk: [{\r\n                type: Input\r\n            }], itemsPerSlide: [{\r\n                type: Input\r\n            }], singleSlideOffset: [{\r\n                type: Input\r\n            }], isAnimated: [{\r\n                type: Input\r\n            }], activeSlideChange: [{\r\n                type: Output\r\n            }], slideRangeChange: [{\r\n                type: Output\r\n            }], activeSlide: [{\r\n                type: Input\r\n            }], startFromIndex: [{\r\n                type: Input\r\n            }], interval: [{\r\n                type: Input\r\n            }] } });\r\n\r\nclass SlideComponent {\r\n    constructor(carousel) {\r\n        /** Is current slide active */\r\n        this.active = false;\r\n        this.itemWidth = '100%';\r\n        this.order = 0;\r\n        this.isAnimated = false;\r\n        /** Wraps element by appropriate CSS classes */\r\n        this.addClass = true;\r\n        this.multilist = false;\r\n        this.carousel = carousel;\r\n    }\r\n    /** Fires changes in container collection after adding a new slide instance */\r\n    ngOnInit() {\r\n        this.carousel.addSlide(this);\r\n        this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\r\n        this.multilist = this.carousel?.itemsPerSlide > 1;\r\n    }\r\n    /** Fires changes in container collection after removing of this slide instance */\r\n    ngOnDestroy() {\r\n        this.carousel.removeSlide(this);\r\n    }\r\n}\r\nSlideComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: SlideComponent, deps: [{ token: CarouselComponent }], target: i0.ɵɵFactoryTarget.Component });\r\nSlideComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"15.0.3\", type: SlideComponent, selector: \"slide\", inputs: { active: \"active\" }, host: { properties: { \"attr.aria-hidden\": \"!active\", \"class.multilist-margin\": \"multilist\", \"class.active\": \"this.active\", \"style.width\": \"this.itemWidth\", \"style.order\": \"this.order\", \"class.carousel-animation\": \"this.isAnimated\", \"class.item\": \"this.addClass\", \"class.carousel-item\": \"this.addClass\" } }, ngImport: i0, template: `\r\n    <div [class.active]=\"active\" class=\"item\">\r\n      <ng-content></ng-content>\r\n    </div>\r\n  `, isInline: true, styles: [\":host.carousel-animation{transition:opacity .6s ease,visibility .6s ease;float:left}:host.carousel-animation.active{opacity:1;visibility:visible}:host.carousel-animation:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}:host.multilist-margin{margin-right:auto}:host.carousel-item{perspective:1000px}\\n\"] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: SlideComponent, decorators: [{\r\n            type: Component,\r\n            args: [{ selector: 'slide', template: `\r\n    <div [class.active]=\"active\" class=\"item\">\r\n      <ng-content></ng-content>\r\n    </div>\r\n  `, host: {\r\n                        '[attr.aria-hidden]': '!active',\r\n                        '[class.multilist-margin]': 'multilist'\r\n                    }, styles: [\":host.carousel-animation{transition:opacity .6s ease,visibility .6s ease;float:left}:host.carousel-animation.active{opacity:1;visibility:visible}:host.carousel-animation:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}:host.multilist-margin{margin-right:auto}:host.carousel-item{perspective:1000px}\\n\"] }]\r\n        }], ctorParameters: function () { return [{ type: CarouselComponent }]; }, propDecorators: { active: [{\r\n                type: HostBinding,\r\n                args: ['class.active']\r\n            }, {\r\n                type: Input\r\n            }], itemWidth: [{\r\n                type: HostBinding,\r\n                args: ['style.width']\r\n            }], order: [{\r\n                type: HostBinding,\r\n                args: ['style.order']\r\n            }], isAnimated: [{\r\n                type: HostBinding,\r\n                args: ['class.carousel-animation']\r\n            }], addClass: [{\r\n                type: HostBinding,\r\n                args: ['class.item']\r\n            }, {\r\n                type: HostBinding,\r\n                args: ['class.carousel-item']\r\n            }] } });\r\n\r\nclass CarouselModule {\r\n    static forRoot() {\r\n        return { ngModule: CarouselModule, providers: [] };\r\n    }\r\n}\r\nCarouselModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nCarouselModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselModule, declarations: [SlideComponent, CarouselComponent], imports: [CommonModule], exports: [SlideComponent, CarouselComponent] });\r\nCarouselModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselModule, imports: [CommonModule] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [CommonModule],\r\n                    declarations: [SlideComponent, CarouselComponent],\r\n                    exports: [SlideComponent, CarouselComponent]\r\n                }]\r\n        }] });\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };\r\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}